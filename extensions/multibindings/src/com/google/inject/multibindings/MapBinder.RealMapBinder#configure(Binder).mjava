    public void configure(Binder binder) {
      checkConfiguration(!isInitialized(), "MapBinder was already initialized");

      final ImmutableSet<Dependency<?>> dependencies
          = ImmutableSet.<Dependency<?>>of(Dependency.get(entrySetBinder.getSetKey()));

      // Binds a Map<K, Provider<V>> from a collection of Set<Entry<K, Provider<V>>.
      final Provider<Set<Entry<K, Provider<V>>>> entrySetProvider = binder
          .getProvider(entrySetBinder.getSetKey());
      
      binder.bind(providerMapKey).toProvider(
          new RealMapBinderProviderWithDependencies<Map<K, Provider<V>>>(mapKey) {
        private Map<K, Provider<V>> providerMap;

        @Toolable @Inject void initialize(Injector injector) {
          RealMapBinder.this.binder = null;
          permitDuplicates = entrySetBinder.permitsDuplicates(injector);

          Map<K, Provider<V>> providerMapMutable = new LinkedHashMap<K, Provider<V>>();
          List<Map.Entry<K, Binding<V>>> bindingsMutable = Lists.newArrayList();
          Set<K> duplicateKeys = null;
          for (Entry<K, Provider<V>> entry : entrySetProvider.get()) {
            Provider<V> previous = providerMapMutable.put(entry.getKey(), entry.getValue());
            if (previous != null && !permitDuplicates) {
              if (duplicateKeys == null) {
                duplicateKeys = Sets.newHashSet();
              }
              duplicateKeys.add(entry.getKey());
            }
            ProviderMapEntry<K, V> providerEntry = (ProviderMapEntry<K, V>) entry;
            Key<V> valueKey = providerEntry.getValueKey();
            bindingsMutable.add(Maps.immutableEntry(entry.getKey(), injector.getBinding(valueKey)));
          }
          if (duplicateKeys != null) {
            Multimap<K, String> dups = LinkedHashMultimap.create();
            for (Map.Entry<K, Binding<V>> entry : bindingsMutable) {
              if (duplicateKeys.contains(entry.getKey())) {
                dups.put(entry.getKey(), "\t at " + Errors.convert(entry.getValue().getSource()));
              }
            }
            StringBuilder sb = new StringBuilder("Map injection failed due to duplicated key ");
            boolean first = true;
            for (K key : dups.keySet()) {
              if (first) {
                first = false;
                if (duplicateKeyErrorMessages.containsKey(key)) {
                  sb.setLength(0);
                  sb.append(duplicateKeyErrorMessages.get(key));
                } else {
                  sb.append("\"" + key + "\", from bindings:\n");
                }
              } else {
                if (duplicateKeyErrorMessages.containsKey(key)) {
                  sb.append("\n and " + duplicateKeyErrorMessages.get(key));
                } else {
                  sb.append("\n and key: \"" + key + "\", from bindings:\n");
                }
              }
              Joiner.on('\n').appendTo(sb, dups.get(key)).append("\n");
            }
            checkConfiguration(false, sb.toString());
          }

          providerMap = ImmutableMap.copyOf(providerMapMutable);
          mapBindings = ImmutableList.copyOf(bindingsMutable);
        }

        public Map<K, Provider<V>> get() {
          return providerMap;
        }

        public Set<Dependency<?>> getDependencies() {
          return dependencies;
        }
      });
      
      // The map this exposes is internally an ImmutableMap, so it's OK to massage
      // the guice Provider to javax Provider in the value (since Guice provider
      // implements javax Provider).
      @SuppressWarnings("unchecked")
      Key massagedProviderMapKey = (Key)providerMapKey;
      binder.bind(javaxProviderMapKey).to(massagedProviderMapKey);

      final Provider<Map<K, Provider<V>>> mapProvider = binder.getProvider(providerMapKey);
      binder.bind(mapKey).toProvider(new RealMapWithExtensionProvider<Map<K, V>>(mapKey) {
        public Map<K, V> get() {
          Map<K, V> map = new LinkedHashMap<K, V>();
          for (Entry<K, Provider<V>> entry : mapProvider.get().entrySet()) {
            V value = entry.getValue().get();
            K key = entry.getKey();
            checkConfiguration(value != null,
                "Map injection failed due to null value for key \"%s\"", key);
            map.put(key, value);
          }
          return Collections.unmodifiableMap(map);
        }

        public Set<Dependency<?>> getDependencies() {
          return dependencies;
        }

        @SuppressWarnings("unchecked")
        public <B, R> R acceptExtensionVisitor(BindingTargetVisitor<B, R> visitor,
            ProviderInstanceBinding<? extends B> binding) {
          if (visitor instanceof MultibindingsTargetVisitor) {
            return ((MultibindingsTargetVisitor<Map<K, V>, R>)visitor).visit(this);
          } else {
            return visitor.visit(binding);
          }
        }

        public Key<Map<K, V>> getMapKey() {
          return mapKey;
        }

        public TypeLiteral<?> getKeyTypeLiteral() {
          return keyType;
        }

        public TypeLiteral<?> getValueTypeLiteral() {
          return valueType;
        }

        @SuppressWarnings("unchecked")
        public List<Entry<?, Binding<?>>> getEntries() {
          if (isInitialized()) {
            return (List)mapBindings; // safe because mapBindings is immutable
          } else {
            throw new UnsupportedOperationException("getElements() not supported for module bindings");
          }
        }

        public boolean permitsDuplicates() {
          if (isInitialized()) {
            return permitDuplicates;
          } else {
            throw new UnsupportedOperationException("permitsDuplicates() not supported for module bindings");
          }
        }

        public boolean containsElement(com.google.inject.spi.Element element) {
          return RealMapBinder.this.containsElement(element);
        }
      });
    }

