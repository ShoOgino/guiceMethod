  private void bindField(BoundFieldInfo fieldInfo) {
    if (fieldInfo.naturalType.isPresent()) {
      Class<?> naturalRawType = fieldInfo.naturalType.get().getRawType();
      Class<?> boundRawType = fieldInfo.boundType.getRawType();
      if (!boundRawType.isAssignableFrom(naturalRawType)) {
        addErrorAndThrow(
            fieldInfo.field,
            "Requested binding type \"%s\" is not assignable from field binding type \"%s\"",
            boundRawType.getName(),
            naturalRawType.getName());
      }
    }

    AnnotatedBindingBuilder<?> annotatedBinder = binder.bind(fieldInfo.boundType);
    LinkedBindingBuilder<?> binder = verifyBindingAnnotations(fieldInfo.field, annotatedBinder);

    // It's unfortunate that Field.get() just returns Object rather than the actual type (although
    // that would be impossible) because as a result calling binder.toInstance or binder.toProvider
    // is impossible to do without an unchecked cast. This is safe if fieldInfo.naturalType is
    // present because compatibility is checked explicitly above, but is _unsafe_ if
    // fieldInfo.naturalType is absent which occurrs when a non-parameterized Provider is used with
    // @Bind(to = ...)
    @SuppressWarnings("unchecked")
    AnnotatedBindingBuilder<Object> binderUnsafe = (AnnotatedBindingBuilder<Object>) binder;

    Object fieldValue = fieldInfo.getValue();

    if (fieldValue == null) {
      addErrorAndThrow(
          fieldInfo.field,
          "Binding to null values is not allowed. "
          + "Use Providers.of(null) if this is your intended behavior.",
          fieldInfo.field.getName());
    }

    if (isTransparentProvider(fieldInfo.type.getRawType())) {
      // This is safe because we checked that the field's type is Provider above.
      @SuppressWarnings("unchecked")
      Provider<?> fieldValueUnsafe = (Provider<?>) fieldValue;

      binderUnsafe.toProvider(fieldValueUnsafe);
    } else {
      binderUnsafe.toInstance(fieldValue);
    }
  }

