  private void bindField(final BoundFieldInfo fieldInfo) {
    if (fieldInfo.naturalType.isPresent()) {
      Class<?> naturalRawType = fieldInfo.naturalType.get().getRawType();
      Class<?> boundRawType = fieldInfo.boundType.getRawType();
      if (!boundRawType.isAssignableFrom(naturalRawType)) {
        throwBoundFieldException(
            fieldInfo.field,
            "Requested binding type \"%s\" is not assignable from field binding type \"%s\"",
            boundRawType.getName(),
            naturalRawType.getName());
      }
    }

    AnnotatedBindingBuilder<?> annotatedBinder = binder.bind(fieldInfo.boundType);
    LinkedBindingBuilder<?> binder = verifyBindingAnnotations(fieldInfo.field, annotatedBinder);

    // It's unfortunate that Field.get() just returns Object rather than the actual type (although
    // that would be impossible) because as a result calling binder.toInstance or binder.toProvider
    // is impossible to do without an unchecked cast. This is safe if fieldInfo.naturalType is
    // present because compatibility is checked explicitly above, but is _unsafe_ if
    // fieldInfo.naturalType is absent which occurrs when a non-parameterized Provider is used with
    // @Bind(to = ...)
    @SuppressWarnings("unchecked")
    AnnotatedBindingBuilder<Object> binderUnsafe = (AnnotatedBindingBuilder<Object>) binder;

    if (isTransparentProvider(fieldInfo.type.getRawType())) {
      if (fieldInfo.bindAnnotation.lazy()) {
        // We don't support this because it is confusing about when values are captured.
        throwBoundFieldException(fieldInfo.field, 
            "'lazy' is incompatible with Provider valued fields");
      }
      // This is safe because we checked that the field's type is Provider above.
      @SuppressWarnings("unchecked")
      javax.inject.Provider<?> fieldValueUnsafe =
          (javax.inject.Provider<?>) getFieldValue(fieldInfo);
      binderUnsafe.toProvider(fieldValueUnsafe);
    } else if (fieldInfo.bindAnnotation.lazy()) {
      binderUnsafe.toProvider(new Provider<Object>() {
        @Override public Object get() {
          return getFieldValue(fieldInfo);
        }
      });
    } else {
      binderUnsafe.toInstance(getFieldValue(fieldInfo));
    }
  }

