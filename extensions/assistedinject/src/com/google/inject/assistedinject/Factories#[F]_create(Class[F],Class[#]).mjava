  /**
   * Returns a factory that combines caller-provided parameters with injector-provided values when
   * constructing objects.
   *
   * <h3>Defining a Factory</h3>
   * {@code factoryInterface} is an interface whose methods return the constructed type, or its
   * supertypes. The method's parameters are the arguments required to build the constructed type.
   *
   * <pre>
   * public interface PaymentFactory {
   *   Payment create(Date startDate, Money amount);
   * } </pre>
   *
   * You can name your factory methods whatever you like, such as <i>create</i>,
   * <i>createPayment</i> or <i>newPayment</i>.  You may include multiple factory methods in the
   * same interface but they must all construct the same type.
   *
   * <h3>Creating a type that accepts factory parameters</h3>
   * {@code constructedType} is a concrete class with an {@literal @}{@link Inject}-annotated
   * constructor. In addition to injector-provided parameters, the constructor should have
   * parameters that match each of the factory method's parameters. Each factory-provided parameter
   * requires an {@literal @}{@link Assisted} annotation. This serves to document that the parameter
   * is not bound in the injector.
   *
   * <pre>
   * public class RealPayment implements Payment {
   *   {@literal @}Inject
   *   public RealPayment(
   *      CreditService creditService,
   *      AuthService authService,
   *      <strong>{@literal @}Assisted Date startDate</strong>,
   *      <strong>{@literal @}Assisted Money amount</strong>) {
   *     ...
   *   }
   * }</pre>
   *
   * <h3>Configuring factories</h3>
   * In your {@link com.google.inject.Module module}, bind the factory interface to the returned
   * factory:
   *
   * <pre>
   * bind(PaymentFactory.class).toInstance(
   *     Factories.create(PaymentFactory.class, RealPayment.class));</pre>
   * As a side-effect of this binding, Guice will inject the factory to initialize it for use. The
   * factory cannot be used until it has been initialized.
   *
   * <h3>Using the Factory</h3>
   * Inject your factory into your application classes. When you use the factory, your arguments
   * will be combined with values from the injector to produce a concrete instance.
   *
   * <pre>
   * public class PaymentAction {
   *   {@literal @}Inject private PaymentFactory paymentFactory;
   *
   *   public void doPayment(Money amount) {
   *     Payment payment = paymentFactory.create(new Date(), amount);
   *     payment.apply();
   *   }
   * }</pre>
   *
   * <h3>Making Parameter Types Distinct</h3>
   * The types of the factory method's parameters must be distinct. To use multiple parameters of
   * the same type, use a named {@literal @}{@link Assisted} annotation to disambiguate the
   * parameters. The names must be applied to the factory method's parameters:
   *
   * <pre>
   * public interface PaymentFactory {
   *   Payment create(
   *       <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
   *       <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
   *       Money amount);
   * } </pre>
   * ...and to the concrete type's constructor parameters:
   * <pre>
   * public class RealPayment implements Payment {
   *   {@literal @}Inject
   *   public RealPayment(
   *      CreditService creditService,
   *      AuthService authService,
   *      <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
   *      <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
   *      <strong>{@literal @}Assisted</strong> Money amount) {
   *     ...
   *   }
   * }</pre>
   *
   * <h3>MethodInterceptor support</h3>
   * Returned factories delegate to the injector to construct returned values. The values are
   * eligible for method interception.
   *
   * @param factoryInterface a Java interface that defines one or more create methods.
   * @param constructedType a concrete type that is assignable to the return types of all factory
   *     methods.
   */
  public static <F> F create(Class<F> factoryInterface, Class<?> constructedType) {
    RealInvocationHandler<F> invocationHandler
        = new RealInvocationHandler<F>(factoryInterface, Key.get(constructedType));
    Enhancer enhancer = new Enhancer();
    enhancer.setSuperclass(Base.class);
    enhancer.setInterfaces(new Class[] { factoryInterface });
    enhancer.setCallback(invocationHandler);
    return factoryInterface.cast(enhancer.create(ONLY_RIH, new Object[] { invocationHandler }));
  }

