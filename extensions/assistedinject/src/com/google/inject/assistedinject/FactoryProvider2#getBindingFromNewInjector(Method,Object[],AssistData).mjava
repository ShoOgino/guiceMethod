  /**
   * Creates a child injector that binds the args, and returns the binding for the method's result.
   */
  public Binding<?> getBindingFromNewInjector(final Method method, final Object[] args, final AssistData data) {
    checkState(injector != null,
        "Factories.create() factories cannot be used until they're initialized by Guice.");

    final Key<?> returnType = data.returnType;

    // We ignore any pre-existing binding annotation.
    final Key<?> assistedReturnType = Key.get(returnType.getTypeLiteral(), Assisted.class);

    Module assistedModule = new AbstractModule() {
      @SuppressWarnings("unchecked") // raw keys are necessary for the args array and return value
      protected void configure() {
        Binder binder = binder().withSource(method);

        int p = 0;
        if(!data.optimized) {
          for (Key<?> paramKey : data.paramTypes) {
            // Wrap in a Provider to cover null, and to prevent Guice from injecting the parameter
            binder.bind((Key) paramKey).toProvider(Providers.of(args[p++]));
          }
        } else {
          for (Key<?> paramKey : data.paramTypes) {
            // Bind to our ThreadLocalProviders.
            binder.bind((Key) paramKey).toProvider(data.providers.get(p++));
          }
        }

                
        Constructor<?> constructor = data.constructor;
        // If the injector already has a binding for the return type, don't
        // bother binding to a specific constructor. Otherwise, there could be
        // bugs where an implicit binding isn't used (or an explicitly forwarded
        // binding isn't used)
        if (injector.getExistingBinding(returnType) != null) {
          constructor = null;
        }
        
        TypeLiteral<?> implementation = collector.getBindings().get(returnType);
        if (implementation != null) {
          if(constructor == null) {
            binder.bind(assistedReturnType).to((TypeLiteral)implementation);
          } else {
            binder.bind(assistedReturnType).toConstructor((Constructor)constructor, (TypeLiteral)implementation);
          }
        } else {
          // no implementation, but need to bind from assisted key to actual key.
          if(constructor == null) {
            binder.bind(assistedReturnType).to((Key)returnType);
          } else {
            binder.bind(assistedReturnType).toConstructor((Constructor)constructor);
          }
        }
      }
    };

    Injector forCreate = injector.createChildInjector(assistedModule);
    Binding binding = forCreate.getBinding(assistedReturnType);
    // If we have providers cached in data, cache the binding for future optimizations.
    if(data.optimized) {
      data.cachedBinding = binding; 
    }
    return binding;
  }

