    @Override public <T> void writeBind(Binder binder, Binding<T> binding) {
      final Key<T> key = binding.getKey();

      if (!keysToIntercept.contains(key)) {
        super.writeBind(binder, binding);
        return;
      }

      binding.acceptTargetVisitor(new DefaultBindingTargetVisitor<T, Void>() {
        @Override public Void visitUntargetted(UntargettedBinding<T> tUntargettedBinding) {
          throw new UnsupportedOperationException(
              String.format("Cannot intercept bare binding of %s.", key));
        }
      });

      Key<T> anonymousKey = Key.get(key.getTypeLiteral(), UniqueAnnotations.create());
      binder.bind(key).toProvider(new InterceptingProvider<T>(key, anonymousKey));

      ScopedBindingBuilder scopedBindingBuilder = bindKeyToTarget(binding, binder, anonymousKey);

      // we scope the user's provider, not the interceptor. This is dangerous,
      // but convenient. It means that although the user's provider will live
      // in its proper scope, the intereptor gets invoked without a scope
      applyScoping(binding, scopedBindingBuilder);

      keysIntercepted.add(key);
    }

