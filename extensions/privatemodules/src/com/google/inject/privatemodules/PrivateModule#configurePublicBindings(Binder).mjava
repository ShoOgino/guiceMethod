  private void configurePublicBindings(Binder publicBinder) {
    exposes = Sets.newLinkedHashSet();
    Key<Ready> readyKey = Key.get(Ready.class, UniqueAnnotations.create());
    readyProvider = publicBinder.getProvider(readyKey);
    try {
      List<Element> privateElements = Elements.getElements(this); // reentrant on configure()
      Set<Key<?>> privatelyBoundKeys = getBoundKeys(privateElements);
      final Module privateModule = new ModuleWriter().create(privateElements);

      for (Expose<?> expose : exposes) {
        if (!privatelyBoundKeys.contains(expose.key)) {
          publicBinder.addError("Could not expose() at %s%n %s must be explicitly bound.", 
              expose.source, expose.key);
        } else {
          expose.configure(publicBinder);
        }
      }

      // create the private injector while the public injector is injecting its members. This is
      // necessary so the providers from getProvider() will work.
      publicBinder.bind(readyKey).toProvider(new Provider<Ready>() {
        @Inject Injector publicInjector;
        private Ready result;
        public Ready get() {
          // Build the child injector once. This method is called multiple times when we have
          // creation-time dependencies from private on public and from public to private.
          if (result == null) {
            result = new Ready();
            publicInjector.createChildInjector(privateModule);
          }

          return result;
        }
      }).asEagerSingleton();

    } finally {
      readyProvider = null;
      exposes = null;
    }
  }

