  public <T> Provider<T> scope(final Key<T> key, final Provider<T> creator) {
    // lock is referenced from anonymous class instance
    final Object rootInjectorLock = singletonCreationPerRootInjectorLock.get();
    if (rootInjectorLock == null) {
      throw new OutOfScopeException("Singleton scope should only be used from Injector");
    }
    return new Provider<T>() {
      /*
       * The lazily initialized singleton instance. Once set, this will either have type T or will
       * be equal to NULL.
       */
      private volatile Object instance;

      // DCL on a volatile is safe as of Java 5, which we obviously require.
      @SuppressWarnings("DoubleCheckedLocking")
      public T get() {
        if (instance == null) {
          /*
           * Use a pretty coarse lock. We don't want to run into deadlocks
           * when two threads try to load circularly-dependent objects.
           * Maybe one of these days we will identify independent graphs of
           * objects and offer to load them in parallel.
           *
           * This block is re-entrant for circular dependencies.
           */
          synchronized (rootInjectorLock) {
            if (instance == null) {
              T provided = creator.get();

              // don't remember proxies; these exist only to serve circular dependencies
              if (Scopes.isCircularProxy(provided)) {
                return provided;
              }

              Object providedOrSentinel = (provided == null) ? NULL : provided;
              if (instance != null && instance != providedOrSentinel) {
                throw new ProvisionException(
                    "Provider was reentrant while creating a singleton");
              }

              instance = providedOrSentinel;
            }
          }
        }

        Object localInstance = instance;
        // This is safe because instance has type T or is equal to NULL
        @SuppressWarnings("unchecked")
        T returnedInstance = (localInstance != NULL) ? (T) localInstance : null;
        return returnedInstance;
      }

      @Override
      public String toString() {
        return String.format("%s[%s]", creator, Scopes.SINGLETON);
      }
    };
  }

