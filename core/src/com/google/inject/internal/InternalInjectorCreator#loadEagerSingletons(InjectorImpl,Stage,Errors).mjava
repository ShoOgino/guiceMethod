  /**
   * Loads eager singletons, or all singletons if we're in Stage.PRODUCTION. Bindings discovered
   * while we're binding these singletons are not be eager.
   */
  void loadEagerSingletons(InjectorImpl injector, Stage stage, final Errors errors) {
    List<BindingImpl<?>> candidateBindings = new ArrayList<>();
    @SuppressWarnings("unchecked") // casting Collection<Binding> to Collection<BindingImpl> is safe
    Collection<BindingImpl<?>> bindingsAtThisLevel =
        (Collection) injector.state.getExplicitBindingsThisLevel().values();
    candidateBindings.addAll(bindingsAtThisLevel);
    synchronized (injector.state.lock()) {
      // jit bindings must be accessed while holding the lock.
      candidateBindings.addAll(injector.jitBindings.values());
    }
    for (final BindingImpl<?> binding : candidateBindings) {
      if (isEagerSingleton(injector, binding, stage)) {
        try {
          injector.callInContext(
              new ContextualCallable<Void>() {
                Dependency<?> dependency = Dependency.get(binding.getKey());

                @Override
                public Void call(InternalContext context) {
                  Dependency previous = context.pushDependency(dependency, binding.getSource());

                  Errors errorsForBinding = errors.withSource(dependency);
                  try {
                    binding.getInternalFactory().get(errorsForBinding, context, dependency, false);
                  } catch (ErrorsException e) {
                    errorsForBinding.merge(e.getErrors());
                  } finally {
                      context.popStateAndSetDependency(previous);
                    }
                  return null;
                }
              });
        } catch (ErrorsException e) {
          throw new AssertionError();
        }
      }
    }
  }

