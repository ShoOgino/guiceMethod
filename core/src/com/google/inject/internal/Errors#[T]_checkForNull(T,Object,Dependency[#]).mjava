  /**
   * Returns {@code value} if it is non-null or allowed to be null. Otherwise a message is added and
   * an {@code ErrorsException} is thrown.
   */
  public <T> T checkForNull(T value, Object source, Dependency<?> dependency)
      throws ErrorsException {
    if (value != null || dependency.isNullable()) {
      return value;
    }

    // Hack to allow null parameters to @Provides methods, for backwards compatibility.
    if (dependency.getInjectionPoint().getMember() instanceof Method) {
      Method annotated = (Method) dependency.getInjectionPoint().getMember();
      if (annotated.isAnnotationPresent(Provides.class)) {
        switch (InternalFlags.getNullableProvidesOption()) {
          case ERROR:
            break; // break out & let the below exception happen
          case IGNORE:
            return value; // user doesn't care about injecting nulls to non-@Nullables.
          case WARN:
            // Warn only once, otherwise we spam logs too much.
            if (!warnedDependencies.add(dependency)) {
              return value;
            }
            logger.log(
                Level.WARNING,
                "Guice injected null into {0} (a {1}), please mark it @Nullable."
                    + " Use -Dguice_check_nullable_provides_params=ERROR to turn this into an"
                    + " error.",
                new Object[] {formatParameter(dependency), convert(dependency.getKey())});
            return null; // log & exit.
        }
      }
    }

    Object formattedDependency =
        (dependency.getParameterIndex() != -1)
            ? formatParameter(dependency)
            : StackTraceElements.forMember(dependency.getInjectionPoint().getMember());
    addMessage(
        "null returned by binding at %s%n but %s is not @Nullable", source, formattedDependency);

    throw toException();
  }

