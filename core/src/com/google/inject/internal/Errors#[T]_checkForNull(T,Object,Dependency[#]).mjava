  /**
   * Returns {@code value} if it is non-null or allowed to be null. Otherwise a message is added and
   * an {@code ErrorsException} is thrown.
   */
  public <T> T checkForNull(T value, Object source, Dependency<?> dependency)
      throws ErrorsException {
    // TODO(lukes): move this method to InternalProvisionException?  Maybe split into 2, one for
    // ProviderMethods and one for everything else.
    if (value != null || dependency.isNullable()) {
      return value;
    }

    // Hack to allow null parameters to @Provides methods, for backwards compatibility.
    if (dependency.getInjectionPoint().getMember() instanceof Method) {
      Method annotated = (Method) dependency.getInjectionPoint().getMember();
      if (annotated.isAnnotationPresent(Provides.class)) {
        switch (InternalFlags.getNullableProvidesOption()) {
          case ERROR:
            break; // break out & let the below exception happen
          case IGNORE:
            return value; // user doesn't care about injecting nulls to non-@Nullables.
          case WARN:
            // Warn only once, otherwise we spam logs too much.
            if (warnedDependencies.add(dependency)) {
              logger.log(
                  Level.WARNING,
                  "Guice injected null into {0} (a {1}), please mark it @Nullable."
                      + " Use -Dguice_check_nullable_provides_params=ERROR to turn this into an"
                      + " error.",
                  new Object[] {
                    Messages.formatParameter(dependency), Messages.convert(dependency.getKey())
                  });
            }
            return value;
        }
      }
    }

    Object formattedDependency =
        (dependency.getParameterIndex() != -1)
            ? Messages.formatParameter(dependency)
            : StackTraceElements.forMember(dependency.getInjectionPoint().getMember());
    addMessage(
        "null returned by binding at %s%n but %s is not @Nullable", source, formattedDependency);

    throw toException();
  }

