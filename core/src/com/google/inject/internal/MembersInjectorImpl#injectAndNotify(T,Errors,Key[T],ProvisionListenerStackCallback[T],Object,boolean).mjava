  void injectAndNotify(final T instance,
      final Errors errors,
      final Key<T> key, // possibly null!
      final ProvisionListenerStackCallback<T> provisionCallback, // possibly null!
      final Object source,
      final boolean toolableOnly) throws ErrorsException {
    if (instance == null) {
      return;
    }

    injector.callInContext(new ContextualCallable<Void>() {
      @Override
      public Void call(final InternalContext context) throws ErrorsException {
        context.pushState(key, source);
        try {
          if (provisionCallback != null && provisionCallback.hasListeners()) {
            provisionCallback.provision(errors, context, new ProvisionCallback<T>() {
              @Override public T call() {
          injectMembers(instance, errors, context, toolableOnly);
                return instance;
              }
            });
          } else {
            injectMembers(instance, errors, context, toolableOnly);
          }
        } finally {
          context.popState();
        }
        return null;
      }
    });

    // TODO: We *could* notify listeners too here,
    // but it's not clear if we want to.  There's no way to know
    // if a MembersInjector from the usersMemberInjector list wants
    // toolable injections, so do we really want to notify
    // about injection?  (We could take a strategy of only notifying
    // if atleast one InjectionPoint was toolable, in which case
    // the above callInContext could return 'true' if it injected
    // anything.)
    if(!toolableOnly) {
      notifyListeners(instance, errors);
    }
  }

