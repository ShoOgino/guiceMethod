    @Override
    public T get(
        final Errors errors,
        final InternalContext context,
        final Dependency<?> dependency,
        boolean linked)
        throws ErrorsException {
      final ConstructionContext<T> constructionContext = context.getConstructionContext(this);
      // We have a circular reference between bindings. Return a proxy.
      if (constructionContext.isConstructing()) {
        Class<?> expectedType = dependency.getKey().getTypeLiteral().getRawType();
        // TODO: if we can't proxy this object, can we proxy the other object?
        @SuppressWarnings("unchecked")
        T proxyType =
            (T) constructionContext.createProxy(errors, context.getInjectorOptions(), expectedType);
        return proxyType;
      }
      // Optimization: Don't go through the callback stack if no one's listening.
      constructionContext.startConstruction();
      try {
        if (!provisionCallback.hasListeners()) {
          return provision(errors, dependency, context, constructionContext);
        } else {
          return provisionCallback.provision(
              errors,
              context,
              new ProvisionCallback<T>() {
                @Override
                public T call() throws ErrorsException {
                  return provision(errors, dependency, context, constructionContext);
                }
              });
        }
      } finally {
        constructionContext.removeCurrentReference();
        constructionContext.finishConstruction();
      }
    }

