      /** Return locks owned by a thread after a lock specified, inclusive. */
      private List<ID> getAllLockIdsAfter(long threadId, ReentrantCycleDetectingLock lock) {
        List<ID> ids = Lists.newArrayList();
        boolean found = false;
        Collection<ReentrantCycleDetectingLock<?>> ownedLocks = locksOwnedByThread.get(threadId);
        Preconditions.checkNotNull(
            ownedLocks, "Internal error: No locks were found taken by a thread");
        for (ReentrantCycleDetectingLock ownedLock : ownedLocks) {
          if (ownedLock == lock) {
            found = true;
          }
          if (found && ownedLock.lockFactory == this.lockFactory) {
            // All locks are stored in a shared map therefore there is no way to
            // enforce type safety. We know that our cast is valid as we check for a lock's
            // factory. If the lock was generated by the
            // same factory it has to have same type as the current lock.
            @SuppressWarnings("unchecked")
            ID userLockId = (ID) ownedLock.userLockId;
            ids.add(userLockId);
          }
        }
        Preconditions.checkState(
            found,
            "Internal error: We can not find locks that created a cycle that we detected");
        return ids;
      }

