  protected T circularGet(final Provider<? extends T> provider, final Errors errors,
      InternalContext context, final Dependency<?> dependency, boolean linked)
      throws ErrorsException {    
    Class<?> expectedType = dependency.getKey().getTypeLiteral().getRawType();
    final ConstructionContext<T> constructionContext = context.getConstructionContext(this);
    
    // We have a circular reference between constructors. Return a proxy.
    if (constructionContext.isConstructing()) {
      if (!allowProxy) {
        throw errors.circularProxiesDisabled(expectedType).toException();
      } else {
        // TODO: if we can't proxy this object, can we proxy the other object?
        @SuppressWarnings("unchecked")
        T proxyType = (T) constructionContext.createProxy(errors, expectedType);
        return proxyType;
      }
    }

    // Optimization: Don't go through the callback stack if no one's listening.
    if (!provisionCallback.hasListeners()) {
      return provision(provider, errors, dependency, constructionContext);
    } else {
      return provisionCallback.provision(errors, new ProvisionCallback<T>() {
        public T call() throws ErrorsException {
          return provision(provider, errors, dependency, constructionContext);
        }
      });
    }
  }

