      @Override
      public ListMultimap<Long, ID> lockOrDetectPotentialLocksCycle() {
        final long currentThreadId = Thread.currentThread().getId();
        synchronized (CycleDetectingLockFactory.class) {
          checkState();
          // Add this lock to the waiting map to ensure it is included in any reported lock cycle.
          lockThreadIsWaitingOn.put(currentThreadId, this);
          ListMultimap<Long, ID> locksInCycle = detectPotentialLocksCycle();
          if (!locksInCycle.isEmpty()) {
            // We aren't actually going to wait for this lock, so remove it from the map.
            lockThreadIsWaitingOn.remove(currentThreadId);
            // potential deadlock is found, we don't try to take this lock
            return locksInCycle;
          }

        }

        // this may be blocking, but we don't expect it to cause a deadlock
        lockImplementation.lock();

        synchronized (CycleDetectingLockFactory.class) {
          // current thread is no longer waiting on this lock
          lockThreadIsWaitingOn.remove(currentThreadId);
          checkState();

          // mark it as owned by us
          lockOwnerThreadId = currentThreadId;
          lockReentranceCount++;
          // add this lock to the list of locks owned by a current thread
          locksOwnedByThread.put(currentThreadId, this);
        }
        // no deadlock is found, locking successful
        return ImmutableListMultimap.of();
      }

