  protected T circularGet(final Provider<? extends T> provider, final Errors errors,
      InternalContext context, final Dependency<?> dependency,
      ProvisionListenerStackCallback<T> provisionCallback)
      throws ErrorsException {    
    final ConstructionContext<T> constructionContext = context.getConstructionContext(this);

    // We have a circular reference between constructors. Return a proxy.
    if (constructionContext.isConstructing()) {
        Class<?> expectedType = dependency.getKey().getTypeLiteral().getRawType();
        // TODO: if we can't proxy this object, can we proxy the other object?
        @SuppressWarnings("unchecked")
        T proxyType = (T) constructionContext.createProxy(
            errors, context.getInjectorOptions(), expectedType);
        return proxyType;
    }

    // Optimization: Don't go through the callback stack if no one's listening.
    constructionContext.startConstruction();
    try {
      if (!provisionCallback.hasListeners()) {
        return provision(provider, errors, dependency, constructionContext);
      } else {
        return provisionCallback.provision(errors, context, new ProvisionCallback<T>() {
          public T call() throws ErrorsException {
            return provision(provider, errors, dependency, constructionContext);
          }
        });
      }
    } finally {
      constructionContext.removeCurrentReference();
      constructionContext.finishConstruction();
    }
  }

