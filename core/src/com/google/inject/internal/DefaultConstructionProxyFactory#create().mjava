  @Override
  public ConstructionProxy<T> create() {
    @SuppressWarnings("unchecked") // the injection point is for a constructor of T
    final Constructor<T> constructor = (Constructor<T>) injectionPoint.getMember();

    /*if[AOP]*/
    if (BytecodeGen.isFastClassable(constructor)) {
      try {
        Class<T> classToConstruct = constructor.getDeclaringClass();
        net.sf.cglib.reflect.FastClass fc =
            BytecodeGen.newFastClass(classToConstruct);
        int index = fc.getIndex(constructor.getParameterTypes());
        // We could just fall back to reflection in this case but I believe this should actually
        // be impossible.
        Preconditions.checkArgument(index >= 0,
            "Could not find constructor %s in fast class for class %s", 
            constructor, 
            classToConstruct);
        return new FastClassProxy<T>(injectionPoint, constructor, fc, index);
      } catch (net.sf.cglib.core.CodeGenerationException e) {/* fall-through */}
    }
    /*end[AOP]*/

    return new ReflectiveProxy<T>(injectionPoint, constructor);
  }

