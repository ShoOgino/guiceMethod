  public void testIgnoreMethods() {
    class ModuleWithMethodsToIgnore {
      @TestProvides
      boolean booleanTest() {
        return true;
      }

      @TestProvides
      int ignore() {
        return 0;
      }
    }

    class TestScanner extends ModuleAnnotatedMethodScanner {
      @Override
      public Set<? extends Class<? extends Annotation>> annotationClasses() {
        return ImmutableSet.of(TestProvides.class);
      }

      @Override
      public <T> Key<T> prepareMethod(
          Binder binder, Annotation annotation, Key<T> key, InjectionPoint injectionPoint) {
        return key;
      }
    }
    ModuleAnnotatedMethodScanner filteringScanner =
        new TestScanner() {
          @Override
          public <T> Key<T> prepareMethod(
              Binder binder, Annotation annotation, Key<T> key, InjectionPoint injectionPoint) {
            Method method = (Method) injectionPoint.getMember();
            if (method.getName().equals("ignore")) {
              return null;
            }
            return key;
          }
        };
    Injector filteredInjector =
        Guice.createInjector(
            ProviderMethodsModule.forModule(new ModuleWithMethodsToIgnore(), filteringScanner));
    assertTrue(filteredInjector.getInstance(Key.get(Boolean.class)));
    try {
      filteredInjector.getInstance(Integer.class);
      fail();
    } catch (ConfigurationException expected) {
      //
    }
    Injector unfilteredInjector =
        Guice.createInjector(
            ProviderMethodsModule.forModule(new ModuleWithMethodsToIgnore(), new TestScanner()));
    assertTrue(unfilteredInjector.getInstance(Key.get(Boolean.class)));
    assertEquals(Integer.valueOf(0), unfilteredInjector.getInstance(Integer.class));
  }

