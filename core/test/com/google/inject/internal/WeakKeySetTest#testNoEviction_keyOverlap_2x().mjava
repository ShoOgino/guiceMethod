  public void testNoEviction_keyOverlap_2x() {
    TestState state1 = new TestState();
    TestState state2 = new TestState();
    Key<Integer> key1 = Key.get(Integer.class);
    Key<Integer> key2 = Key.get(Integer.class);
    Object source1 = new Object();
    Object source2 = new Object();

    set.add(key1, state1, source1);
    assertTrue(set.contains(key1));
    assertEquals(1, set.getSources(key1).size());
    assertTrue(set.getSources(key1).contains(source1));

    set.add(key2, state2, source2);
    assertTrue(set.contains(key2));
    assertEquals(2, set.getSources(key2).size());
    assertTrue(set.getSources(key1).containsAll(Arrays.asList(source1, source2)));

    WeakReference<Key<Integer>> weakKey1Ref = new WeakReference<Key<Integer>>(key1);
    WeakReference<Key<Integer>> weakKey2Ref = new WeakReference<Key<Integer>>(key2);

    Key<Integer> key = key1 = key2 = Key.get(Integer.class);

    awaitFullGc();

    assertTrue(set.contains(key));
    assertEquals(2, set.getSources(key).size());
    assertTrue(set.getSources(key1).containsAll(Arrays.asList(source1, source2)));

    // Ensure the keys don't get GC'd when states are still referenced. key1 will be present in the
    // as the map key but key2 could be GC'd if the implementation does something wrong.
    assertNotNull(weakKey1Ref.get());
    assertNotNull(weakKey2Ref.get());
  }

