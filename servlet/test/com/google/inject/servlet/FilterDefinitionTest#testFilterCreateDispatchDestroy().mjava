  public final void testFilterCreateDispatchDestroy() throws ServletException, IOException {
    Injector injector = createMock(Injector.class);
    HttpServletRequest request = createMock(HttpServletRequest.class);

    final MockFilter mockFilter = new MockFilter();

    expect(injector.getBinding(Key.get(Filter.class)))
        .andReturn(createMock(Binding.class));

    expect(injector.getInstance(Key.get(Filter.class)))
        .andReturn(mockFilter)
        .anyTimes();

    expect(request.getServletPath()).andReturn("/index.html");

    replay(injector, request);

    String pattern = "/*";
    final FilterDefinition filterDef = new FilterDefinition(pattern, Key.get(Filter.class),
        UriPatternType.get(UriPatternType.SERVLET, pattern), new HashMap<String, String>());
    assert filterDef.getFilter() instanceof MockFilter;

    //should fire on mockfilter now
    filterDef.init(createMock(ServletContext.class), injector);

    assert mockFilter.isInit() : "Init did not fire";

    final boolean proceed[] = new boolean[1];
    filterDef.doFilter(request, null, new FilterChainInvocation(null, null, null) {
      public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse)
          throws IOException, ServletException {

        proceed[0] = true;
      }
    });

    assertTrue("Filter did not proceed down chain", proceed[0]);

    filterDef.destroy();
    assertTrue("Destroy did not fire", mockFilter.isDestroy());

    verify(injector, request);

  }

