  /**
   * Returns all instance method and field injection points on {@code type}. All fields are added
   * first, and then all methods. Within the fields, supertype fields are added before subtype
   * fields. Similarly, supertype methods are added before subtype methods.
   *
   * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
   *      a field with multiple binding annotations. The exception's {@link
   *      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
   *      of the valid injection points.
   */
  public static Set<InjectionPoint> forInstanceMethodsAndFields(TypeLiteral<?> type) {
    List<InjectionPoint> sink = Lists.newArrayList();
    Errors errors = new Errors();

    // TODO (crazybob): Filter out overridden members.
    addInjectionPoints(type, Factory.FIELDS, false, sink, errors);
    addInjectionPoints(type, Factory.METHODS, false, sink, errors);

    ImmutableSet<InjectionPoint> result = ImmutableSet.copyOf(sink);
    if (errors.hasErrors()) {
      throw new ConfigurationException(errors.getMessages()).withPartialValue(result);
    }
    return result;
  }

