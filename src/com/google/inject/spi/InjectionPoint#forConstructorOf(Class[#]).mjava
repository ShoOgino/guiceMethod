  /**
   * Returns a new injection point for the injectable constructor of {@code type}.
   *
   * @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},
   *     or a no-arguments constructor that is not private.
   * @throws RuntimeException if there is no injectable constructor, more than one injectable
   *     constructor, or if parameters of the injectable constructor are malformed, such as a
   *     parameter with multiple binding annotations.
   */
  public static InjectionPoint forConstructorOf(Class<?> type) {
    Errors errors = new Errors(type);

    Constructor<?> found = null;
    for (Constructor<?> constructor : type.getDeclaredConstructors()) {
      Inject inject = constructor.getAnnotation(Inject.class);
      if (inject != null) {
        if (inject.optional()) {
          errors.optionalConstructor(constructor);
        }

        if (found != null) {
          errors.tooManyConstructors(type);
        }

        found = constructor;
      }
    }

    ConfigurationException.throwNewIfNonEmpty(errors);

    if (found != null) {
      return get(found);
    }

    // If no annotated constructor is found, look for a no-arg constructor
    // instead.
    try {
      Constructor<?> noArgCtor = type.getDeclaredConstructor();

      // Disallow private constructors on non-private classes (unless they have @Inject)
      if (Modifier.isPrivate(noArgCtor.getModifiers())
          && !Modifier.isPrivate(type.getModifiers())) {
        errors.missingConstructor(type);
        throw new ConfigurationException(errors);
      }

      return get(noArgCtor);
    } catch (NoSuchMethodException e) {
      errors.missingConstructor(type);
      throw new ConfigurationException(errors);
    }
  }

