  <T> InternalFactory<? extends T> getFactory(Member member, Key<T> key) {
    // TODO: Clean up unchecked type warnings.

    // Do we have a factory for the specified type and name?
    Binding<T> binding = getBinding(key);
    if (binding != null) {
      return binding.getInternalFactory();
    }

    // Handle cases where T is a Factory<?>.
    if (key.getType().getRawType().equals(Factory.class)) {
      Type factoryType = key.getType().getType();
      if (!(factoryType instanceof ParameterizedType)) {
        return null;
      }
      Type entryType =
          ((ParameterizedType) factoryType).getActualTypeArguments()[0];

      try {
        final Factory<?> factory =
            getFactory(Key.get(entryType, key.getName()));
        return new InternalFactory<T>() {
          @SuppressWarnings({"unchecked"})
          public T get(InternalContext context) {
            return (T) factory;
          }
        };
      } catch (ConfigurationException e) {
        errorHandler.handle(ErrorMessage.MISSING_BINDING, member, key);
        return invalidFactory();
      }
    }

    // Auto[un]box primitives.
    Class<?> primitiveCounterpart =
        PRIMITIVE_COUNTERPARTS.get(key.getType().getRawType());
    if (primitiveCounterpart != null) {
      Binding<?> counterpartBinding =
          getBinding(Key.get(primitiveCounterpart, key.getName()));
      if (counterpartBinding != null) {
        return (InternalFactory<T>) counterpartBinding.getInternalFactory();
      }
    }

    // Do we have a constant String factory of the same name?
    Binding<String> stringBinding =
        getBinding(Key.get(String.class, key.getName()));
    if (stringBinding == null || !stringBinding.isConstant()) {
      return null;
    }

    Class<?> type = key.getRawType();

    // We don't need do pass in an InternalContext because we know this is
    // a ConstantFactory which will not use it.
    String value = stringBinding.getInternalFactory().get(null);

    // TODO: Generalize everything below here and enable users to plug in
    // their own converters.

    // Do we need a primitive?
    Converter<T> converter = (Converter<T>) PRIMITIVE_CONVERTERS.get(type);
    if (converter != null) {
      try {
        T t = converter.convert(member, key, value);
        return new ConstantFactory<T>(t);
      } catch (ConstantConversionException e) {
        errorHandler.handle(e);
        return null;
      }
    }

    // Do we need an enum?
    if (Enum.class.isAssignableFrom(type)) {
      T t = null;
      try {
        t = (T) Enum.valueOf((Class) type, value);
      } catch (IllegalArgumentException e) {
        errorHandler.handle(
            ConstantConversionException.createMessage(
                value, key, member, e.toString()));
        return invalidFactory();
      }
      return new ConstantFactory<T>(t);
    }

    // Do we need a class?
    if (type == Class.class) {
      try {
        return new ConstantFactory<T>((T) Class.forName(value));
      } catch (ClassNotFoundException e) {
        errorHandler.handle(
            ConstantConversionException.createMessage(
                value, key, member, e.toString()));
        return invalidFactory();
      }
    }

    return null;
  }

