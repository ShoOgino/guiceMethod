  /**
   * Gets parameter injectors.
   *
   * @param member to which the parameters belong
   * @param annotations on the parameters
   * @param parameterTypes parameter types
   * @return injections
   */
  <M extends AccessibleObject & Member>
  ParameterInjector<?>[] getParametersInjectors(M member,
      Annotation[][] annotations, Type[] parameterTypes, String defaultName)
      throws MissingDependencyException {
    boolean defaultNameOverridden = !defaultName.equals(Key.DEFAULT_NAME);

    // We only carry over the name from the member level annotation to the
    // parameters if there's only one parameter.
    if (parameterTypes.length != 1 && defaultNameOverridden) {
      errorHandler.handle(
          ErrorMessages.NAME_ON_MEMBER_WITH_MULTIPLE_PARAMS, member);
    }

    ParameterInjector<?>[] parameterInjectors
        = new ParameterInjector<?>[parameterTypes.length];
    Iterator<Annotation[]> annotationsIterator
        = Arrays.asList(annotations).iterator();
    int index = 0;
    for (Type parameterType : parameterTypes) {
      Annotation[] parameterAnnotations = annotationsIterator.next();
      Inject inject = null;
      try {
        inject = SurrogateAnnotations.findAnnotation(Inject.class,
            parameterAnnotations);
      } catch (DuplicateAnnotationException e) {
        errorHandler.handle(ErrorMessages.DUPLICATE_ANNOTATIONS,
            Inject.class.getSimpleName(), member, e.getFirst(),
            e.getSecond());
      }

      String name;
      if (defaultNameOverridden) {
        name = defaultName;
        if (inject != null) {
          errorHandler.handle(
              ErrorMessages.NAME_ON_MEMBER_AND_PARAMETER, member);
        }
      }
      else {
        name = inject == null ? defaultName : inject.value();
      }

      Key<?> key = Key.get(parameterType, name);
      parameterInjectors[index] = createParameterInjector(key, member, index);
      index++;
    }

    return parameterInjectors;
  }

