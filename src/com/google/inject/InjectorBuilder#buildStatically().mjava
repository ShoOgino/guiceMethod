  /**
   * Synchronize while we're building up the bindings and other injector state. This ensures that
   * the JIT bindings in the parent injector don't change while we're being built
   */
  void buildStatically() {
    synchronized (injector.state.lock()) {
      // bind Stage and Singleton if this is a top-level injector
      if (parent == null) {
        modules.add(0, new RootModule(stage));
      }

      elements.addAll(Elements.getElements(stage, modules));
      stopwatch.resetAndLog("Module execution");

      new MessageProcessor(errors).processCommands(elements);

      InterceptorBindingProcessor interceptorCommandProcessor
          = new InterceptorBindingProcessor(errors, injector.state);
      interceptorCommandProcessor.processCommands(elements);
      injector.constructionProxyFactory = interceptorCommandProcessor.createProxyFactory();
      stopwatch.resetAndLog("Interceptors creation");

      new ScopeBindingProcessor(errors, injector.state).processCommands(elements);
      stopwatch.resetAndLog("Scopes creation");

      new TypeConverterBindingProcessor(errors, injector.state).processCommands(elements);
      stopwatch.resetAndLog("Converters creation");

      bindInjector();
      bindLogger();
      bindCommandProcesor = new BindingProcessor(errors,
          injector, injector.state, injector.initializer);
      bindCommandProcesor.processCommands(elements);
      bindCommandProcesor.createUntargettedBindings();
      stopwatch.resetAndLog("Binding creation");

      injector.index();
      stopwatch.resetAndLog("Binding indexing");

      injectionCommandProcessor = new InjectionRequestProcessor(errors, injector.initializer);
      injectionCommandProcessor.processCommands(elements);
      stopwatch.resetAndLog("Static injection");

      validateStatically();

      if (!elements.isEmpty()) {
        throw new AssertionError("Failed to execute " + elements);
      }
    }
  }

