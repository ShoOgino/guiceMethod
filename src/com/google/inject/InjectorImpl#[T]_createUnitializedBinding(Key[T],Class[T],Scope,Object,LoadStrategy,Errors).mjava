  /**
   * Creates a binding for an injectable type with the given scope. Looks for a scope on the type if
   * none is specified.
   *
   * TODO(jessewilson): Fix raw types! this method makes a binding for {@code Foo} from a request
   *     for {@code Foo<String>}
   *
   * @param type the raw type for {@code key}
   */
  <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Class<T> type, Scope scope, Object source,
      LoadStrategy loadStrategy, Errors errors) throws ErrorsException {
    // Don't try to inject arrays, or enums.
    if (type.isArray() || type.isEnum()) {
      throw errors.missingImplementation(type).toException();
    }

    // Handle @ImplementedBy
    ImplementedBy implementedBy = type.getAnnotation(ImplementedBy.class);
    if (implementedBy != null) {
      Annotations.checkForMisplacedScopeAnnotations(type, source, errors);
      return createImplementedByBinding(type, scope, implementedBy, loadStrategy, errors);
    }

    // Handle @ProvidedBy.
    ProvidedBy providedBy = type.getAnnotation(ProvidedBy.class);
    if (providedBy != null) {
      Annotations.checkForMisplacedScopeAnnotations(type, source, errors);
      return createProvidedByBinding(type, scope, providedBy, loadStrategy, errors);
    }

    // We can't inject abstract classes.
    // TODO: Method interceptors could actually enable us to implement
    // abstract types. Should we remove this restriction?
    if (Modifier.isAbstract(type.getModifiers())) {
      throw errors.missingImplementation(key).toException();
    }

    // Error: Inner class.
    if (Classes.isInnerClass(type)) {
      throw errors.cannotInjectInnerClass(type).toException();
    }

    if (scope == null) {
      Class<? extends Annotation> scopeAnnotation = Annotations.findScopeAnnotation(errors, type);
      if (scopeAnnotation != null) {
        scope = scopes.get(scopeAnnotation);
        if (scope == null) {
          errors.withSource(type).scopeNotFound(scopeAnnotation);
        }
      }
    }

    Key<T> keyForRawType = Key.get(type);

    LateBoundConstructor<T> lateBoundConstructor = new LateBoundConstructor<T>();
    InternalFactory<? extends T> scopedFactory
        = Scopes.scope(keyForRawType, this, lateBoundConstructor, scope);
    return new ClassBindingImpl<T>(
        this, keyForRawType, source, scopedFactory, scope, lateBoundConstructor, loadStrategy);
  }

