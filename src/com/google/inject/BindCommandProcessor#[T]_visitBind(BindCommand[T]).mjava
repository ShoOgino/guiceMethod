  @Override public <T> Boolean visitBind(BindCommand<T> command) {
    final Object source = command.getSource();

    final Key<T> key = command.getKey();
    Class<? super T> rawType = key.getTypeLiteral().getRawType();

    if (rawType == Provider.class) {
      addError(source, ErrorMessages.BINDING_TO_PROVIDER);
      return true;
    }

    if (Logger.class == rawType) {
      // TODO(jessewilson): assert this is coming from the internal module?
      // addError(source, ErrorMessages.LOGGER_ALREADY_BOUND);
      // return true;
    }

    validateKey(command.getSource(), command.getKey());

    // TODO(jessewilson): Scope annotation on type, like @Singleton
    final boolean shouldPreload = command.getScoping().isEagerSingleton();
    final Scope scope = command.getScoping().acceptVisitor(new BindScoping.Visitor<Scope>() {
      public Scope visitEagerSingleton() {
        return Scopes.SINGLETON;
      }

      public Scope visitScope(Scope scope) {
        return scope;
      }

      public Scope visitScopeAnnotation(Class<? extends Annotation> scopeAnnotation) {
        Scope scope = scopes.get(scopeAnnotation);
        if (scope != null) {
          return scope;
        } else {
          addError(source, ErrorMessages.SCOPE_NOT_FOUND,
              "@" + scopeAnnotation.getSimpleName());
          return Scopes.NO_SCOPE;
        }
      }

      public Scope visitNoScoping() {
        return null;
      }
    });

    command.getTarget().acceptVisitor(new BindTarget.Visitor<T, Void>() {
      public Void visitToInstance(T instance) {
        InternalFactory<? extends T> factory = new ConstantFactory<T>(instance);
        registerInstanceForInjection(instance);
        InternalFactory<? extends T> scopedFactory
            = Scopes.scope(key, injector, factory, scope);
        createBinding(source, shouldPreload, new InstanceBindingImpl<T>(
            injector, key, source, scopedFactory, instance));
        return null;
      }

      public Void visitToProvider(Provider<? extends T> provider) {
        InternalFactory<? extends T> factory
            = new InternalFactoryToProviderAdapter<T>(provider, source);
        registerInstanceForInjection(provider);
        InternalFactory<? extends T> scopedFactory
            = Scopes.scope(key, injector, factory, scope);
        createBinding(source, shouldPreload, new ProviderInstanceBindingImpl<T>(
            injector, key, source, scopedFactory, scope, provider));
        return null;
      }

      public Void visitToProviderKey(Key<? extends Provider<? extends T>> providerKey) {
        final BoundProviderFactory<T> boundProviderFactory =
            new BoundProviderFactory<T>(providerKey, source);
        creationListeners.add(boundProviderFactory);
        InternalFactory<? extends T> scopedFactory = Scopes.scope(
            key, injector, (InternalFactory<? extends T>) boundProviderFactory, scope);
        createBinding(source, shouldPreload, new LinkedProviderBindingImpl<T>(
            injector, key, source, scopedFactory, scope, providerKey));
        return null;
      }

      public Void visitToKey(Key<? extends T> targetKey) {
        if (key.equals(targetKey)) {
          addError(source, ErrorMessages.RECURSIVE_BINDING);
        }

        FactoryProxy<T> factory = new FactoryProxy<T>(key, targetKey, source);
        creationListeners.add(factory);
        InternalFactory<? extends T> scopedFactory
            = Scopes.scope(key, injector, factory, scope);
        createBinding(source, shouldPreload, new LinkedBindingImpl<T>(
            injector, key, source, scopedFactory, scope, targetKey));
        return null;
      }

      public Void visitUntargetted() {
        Type type = key.getTypeLiteral().getType();

        // Error: Missing implementation.
        // Example: bind(Date.class).annotatedWith(Red.class);
        // We can't assume abstract types aren't injectable. They may have an
        // @ImplementedBy annotation or something.
        if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
          addError(source, ErrorMessages.MISSING_IMPLEMENTATION);
          createBinding(source, shouldPreload, invalidBinding(injector, key, source));
          return null;
        }

        // This cast is safe after the preceeding check.
        @SuppressWarnings("unchecked")
        Class<T> clazz = (Class<T>) type;

        BindingImpl<T> binding = injector.createBindingFromType(clazz, scope, source);
        // TODO: Should we clean up the binding left behind in jitBindings?

        if (binding == null) {
          addError(source, ErrorMessages.CANNOT_INJECT_ABSTRACT_TYPE, clazz);
          createBinding(source, shouldPreload, invalidBinding(injector, key, source));
          return null;
        }

        createBinding(source, shouldPreload, binding);
        return null;
      }
    });

    return true;
  }

