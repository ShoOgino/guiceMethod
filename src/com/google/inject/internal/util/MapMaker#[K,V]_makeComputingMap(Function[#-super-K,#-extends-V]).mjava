  /**
   * Builds a map that supports atomic, on-demand computation of values. {@link
   * Map#get} returns the value corresponding to the given key, atomically
   * computes it using the computer function passed to this builder, or waits
   * for another thread to compute the value if necessary. Only one value will
   * be computed for each key at a given time.
   *
   * <p>If an entry's value has not finished computing yet, query methods
   * besides {@link java.util.Map#get} return immediately as if an entry doesn't
   * exist. In other words, an entry isn't externally visible until the value's
   * computation completes.
   *
   * <p>{@link Map#get} in the returned map implementation throws:
   *
   * <ul>
   * <li>{@link NullPointerException} if the key is null or the computer returns
   *     null</li>
   * <li>or {@link ComputationException} wrapping an exception thrown by the
   *     computation</li>
   * </ul>
   *
   * <p><b>Note:</b> Callers of {@code get()} <i>must</i> ensure that the key
   * argument is of type {@code K}. {@code Map.get()} takes {@code Object}, so
   * the key type is not checked at compile time. Passing an object of a type
   * other than {@code K} can result in that object being unsafely passed to the
   * computer function as type {@code K} not to mention the unsafe key being
   * stored in the map.
   *
   * <p>If {@link java.util.Map#put} is called before a computation completes,
   * other threads waiting on the computation will wake up and return the put
   * value up until the computation completes, at which point the computation
   * result will overwrite the value from the {@code put} in the map.
   */
  public <K, V> ConcurrentMap<K, V> makeComputingMap(
      Function<? super K, ? extends V> computer) {
    return new StrategyImpl<K, V>(this, computer).map;
  }

