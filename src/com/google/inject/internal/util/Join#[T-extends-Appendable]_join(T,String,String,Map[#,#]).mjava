  /**
   * Appends the contents of {@code map} to {@code appendable}, with entries
   * separated by {@code entryDelimiter}, and keys and values separated with
   * {@code keyValueSeparator}.
   *
   * <p>Each key and value will be converted to a {@link CharSequence} using
   * {@link String#valueOf(Object)}, if it isn't a {@link CharSequence} already.
   * Note that this implies that null tokens will be appended as the
   * four-character string {@code "null"}.
   *
   * @param appendable the object to append the results to
   * @param keyValueSeparator a string to append between every key and its
   *     associated value
   * @param entryDelimiter a string to append between every entry, but not at
   *     the beginning or end
   * @param map the map containing the data to join
   * @return the same {@code Appendable} instance that was passed in
   */
  public static <T extends Appendable> T join(T appendable,
      String keyValueSeparator, String entryDelimiter, Map<?, ?> map) {
    Preconditions.checkNotNull(appendable);
    Preconditions.checkNotNull(keyValueSeparator);
    Preconditions.checkNotNull(entryDelimiter);
    Iterator<? extends Map.Entry<?, ?>> entries = map.entrySet().iterator();
    if (entries.hasNext()) {
      try {
        appendOneEntry(appendable, keyValueSeparator, entries.next());
        while (entries.hasNext()) {
          appendable.append(entryDelimiter);
          appendOneEntry(appendable, keyValueSeparator, entries.next());
        }
      } catch (IOException e) {
        throw new JoinException(e);
      }
    }
    return appendable;
  }

