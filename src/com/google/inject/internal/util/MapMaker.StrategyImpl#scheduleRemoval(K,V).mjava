    void scheduleRemoval(K key, V value) {
      /*
       * TODO: Keep weak reference to map, too. Build a priority
       * queue out of the entries themselves instead of creating a
       * task per entry. Then, we could have one recurring task per
       * map (which would clean the entire map and then reschedule
       * itself depending upon when the next expiration comes). We
       * also want to avoid removing an entry prematurely if the
       * entry was set to the same value again.
       */
      final WeakReference<K> keyReference = new WeakReference<K>(key);
      final WeakReference<V> valueReference = new WeakReference<V>(value);
      ExpirationTimer.instance.schedule(
          new TimerTask() {
            public void run() {
              K key = keyReference.get();
              if (key != null) {
                // Remove if the value is still the same.
                map.remove(key, valueReference.get());
              }
            }
          }, TimeUnit.NANOSECONDS.toMillis(expirationNanos));
    }

