  /**
   * Creates a {@link Container} instance. Injects static members for classes
   * which were registered using {@link #requestStaticInjection(Class...)}.
   *
   * @param loadSingletons If true, the container will load all singletons
   *  now. If false, the container will lazily load singletons. Eager loading
   *  is appropriate for production use while lazy loading can speed
   *  development.
   * @throws IllegalStateException if called more than once
   */
  public Container create(boolean loadSingletons) {
    ensureNotCreated();
    created = true;

    HashMap<Key<?>, InternalFactory<?>> factories =
        new HashMap<Key<?>, InternalFactory<?>>();
    ContainerImpl container = new ContainerImpl(factories);

    for (ConstantBindingBuilder builder : constantBindingBuilders) {
      if (builder.hasValue()) {
        Key<?> key = builder.getKey();
        InternalFactory<?> factory = builder.getInternalFactory();
        factories.put(key, factory);
      } else {
        add(new ErrorMessage(builder.getSource(),
            "Constant value isn't set."));
      }
    }

    final List<ContainerImpl.ContextualCallable<Void>> singletonLoaders =
        new ArrayList<ContainerImpl.ContextualCallable<Void>>();

    for (BindingBuilder<?> builder : bindingBuilders) {
      final Key<?> key = builder.getKey();
      final InternalFactory<?> factory = builder.getInternalFactory(container);
      factories.put(key, factory);

      if (builder.isSingleton()) {
        singletonLoaders.add(new ContainerImpl.ContextualCallable<Void>() {
          public Void call(InternalContext context) {
            context.setExternalContext(
                ExternalContext.newInstance(null, key,
                    context.getContainerImpl()));
            try {
              factory.get(context);
              return null;
            } finally {
              context.setExternalContext(null);
            }
          }
        });
      }
    }

    for (LinkedBindingBuilder<?> builder : linkedBindingBuilders) {
      // TODO: Support alias to a later-declared alias.
      Key<?> destination = builder.getDestination();
      if (destination == null) {
        add(new ErrorMessage(builder.getSource(),
            "Link destination isn't set."));
        continue;
      }

      InternalFactory<?> factory = factories.get(destination);
      if (factory == null) {
        add(new ErrorMessage(builder.getSource(),
            "Destination of link binding not found: " + destination));
        continue;
      }

      factories.put(builder.getKey(), factory);
    }

    // Run validations.
    for (Validation validation : validations) {
      validation.run(container);
    }

    if (!errorMessages.isEmpty()) {
      StringBuilder error = new StringBuilder();
      error.append("Configuration errors:\n");
      for (ErrorMessage errorMessage : errorMessages) {
        error.append(errorMessage).append('\n');
      }
      logger.severe(error.toString());
      throw new ConfigurationException("Encountered configuration errors."
        + " See the log for details.");
    }
    container.setErrorHandler(new RuntimeErrorHandler());

    container.injectStatics(staticInjections);

    if (loadSingletons) {
      container.callInContext(new ContainerImpl.ContextualCallable<Void>() {
        public Void call(InternalContext context) {
          for (ContainerImpl.ContextualCallable<Void> singletonLoader
              : singletonLoaders) {
            singletonLoader.call(context);
          }
          return null;
        }
      });
    }

    return container;
  }

