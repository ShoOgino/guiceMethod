  /**
   * Creates a {@link Container} instance. Injects static members for classes
   * which were registered using {@link #requestStaticInjection(Class...)}.
   *
   * @param preload If true, the container will load all container-scoped
   *  bindings now. If false, the container will lazily load them. Eager
   *  loading is appropriate for production use (catch errors early and take
   *  any performance hit up front) while lazy loading can speed development.
   *
   * @throws IllegalStateException if called more than once
   */
  public Container create(boolean preload) {
    ensureNotCreated();
    created = true;

    HashMap<Key<?>, InternalFactory<?>> factories =
        new HashMap<Key<?>, InternalFactory<?>>();
    ContainerImpl container = new ContainerImpl(factories);

    for (ConstantBindingBuilder builder : constantBindingBuilders) {
      if (builder.hasValue()) {
        Key<?> key = builder.getKey();
        InternalFactory<?> factory = builder.getInternalFactory();
        putFactory(builder.getSource(), factories, key, factory);
      } else {
        addError(builder.getSource(), ErrorMessage.MISSING_CONSTANT_VALUE);
      }
    }

    final List<ContainerImpl.ContextualCallable<Void>> preloaders =
        new ArrayList<ContainerImpl.ContextualCallable<Void>>();

    for (BindingBuilder<?> builder : bindingBuilders) {
      final Key<?> key = builder.getKey();
      final InternalFactory<?> factory = builder.getInternalFactory(container);
      putFactory(builder.getSource(), factories, key, factory);

      if (builder.isInContainerScope()) {
        preloaders.add(new ContainerImpl.ContextualCallable<Void>() {
          public Void call(InternalContext context) {
            context.setExternalContext(
                ExternalContext.newInstance(null, key,
                    context.getContainerImpl()));
            try {
              factory.get(context);
              return null;
            } finally {
              context.setExternalContext(null);
            }
          }
        });
      }
    }

    for (LinkedBindingBuilder<?> builder : linkedBindingBuilders) {
      // TODO: Support alias to a later-declared alias.
      Key<?> destination = builder.getDestination();
      if (destination == null) {
        addError(builder.getSource(), ErrorMessage.MISSING_LINK_DESTINATION);
        continue;
      }

      InternalFactory<?> factory = factories.get(destination);
      if (factory == null) {
        addError(builder.getSource(), ErrorMessage.LINK_DESTINATION_NOT_FOUND,
            destination);
        continue;
      }

      putFactory(builder.getSource(), factories, builder.getKey(), factory);
    }

    // Run validations.
    for (Validation validation : validations) {
      validation.run(container);
    }

    if (!errorMessages.isEmpty()) {
      StringBuilder error = new StringBuilder();
      error.append("Guice configuration errors:\n\n");
      int index = 1;
      for (ErrorMessage errorMessage : errorMessages) {
        error.append(index++)
            .append(". ")
            .append("at ")
            .append(errorMessage.getSource())
            .append(':')
            .append('\n')
            .append("  ")
            .append(errorMessage.getMessage())
            .append("\n\n");
      }
      error.append(errorMessages.size()).append(" error[s]\n");
      logger.severe(error.toString());
      throw new ConfigurationException("Encountered configuration errors."
        + " See the log for details.");
    }
    container.setErrorHandler(new RuntimeErrorHandler());

    container.injectStatics(staticInjections);

    if (preload) {
      container.callInContext(new ContainerImpl.ContextualCallable<Void>() {
        public Void call(InternalContext context) {
          for (ContainerImpl.ContextualCallable<Void> preloader
              : preloaders) {
            preloader.call(context);
          }
          return null;
        }
      });
    }

    return container;
  }

