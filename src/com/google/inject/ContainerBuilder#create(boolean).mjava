  /**
   * Creates a {@link Container} instance. Injects static members for classes
   * which were registered using {@link #requestStaticInjection(Class...)}.
   *
   * @param preload If true, the container will load all container-scoped
   *  bindings now. If false, the container will lazily load them. Eager
   *  loading is appropriate for production use (catch errors early and take
   *  any performance hit up front) while lazy loading can speed development.
   *
   * @throws ContainerCreationException if configuration errors are found. The
   *  expectation is that the application will log this exception and exit.
   * @throws IllegalStateException if called more than once
   */
  public synchronized Container create(boolean preload)
      throws ContainerCreationException {
    // Only one Container per builder.
    ensureNotCreated();
    created = true;

    stopwatch.resetAndLog(logger, "Configuration");

    // Create the container.
    HashMap<Key<?>, InternalFactory<?>> factories =
        new HashMap<Key<?>, InternalFactory<?>>();
    ContainerImpl container = new ContainerImpl(factories);

    createConstantBindings(factories);

    // Commands to execute before returning the Container instance.
    final List<ContainerImpl.ContextualCallable<Void>> preloaders =
        new ArrayList<ContainerImpl.ContextualCallable<Void>>();

    createBindings(container, factories, preload, preloaders);
    createLinkedBindings(factories);

    stopwatch.resetAndLog(logger, "Binding creation");

    // Run validations.
    for (Validation validation : validations) {
      validation.run(container);
    }

    stopwatch.resetAndLog(logger, "Validation");

    for (StaticInjection staticInjection : staticInjections) {
      staticInjection.createInjectors(container);
    }

    stopwatch.resetAndLog(logger, "Static validation");

    // Blow up.
    if (!errorMessages.isEmpty()) {
      throw new ContainerCreationException(createErrorMessage());
    }

    // Switch to runtime error handling.
    container.setErrorHandler(new RuntimeErrorHandler());

    // Inject static members.
    for (StaticInjection staticInjection : staticInjections) {
      staticInjection.runInjectors(container);
    }

    stopwatch.resetAndLog(logger, "Static member injection");

    // Run preloading commands.
    if (preload) {
      container.callInContext(new ContainerImpl.ContextualCallable<Void>() {
        public Void call(InternalContext context) {
          for (ContainerImpl.ContextualCallable<Void> preloader
              : preloaders) {
            preloader.call(context);
          }
          return null;
        }
      });
    }

    stopwatch.resetAndLog(logger, "Preloading");

    return container;
  }

