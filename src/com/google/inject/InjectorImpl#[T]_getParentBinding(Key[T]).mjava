  /**
   * Checks the parent injector for a scoped binding, and if available, creates an appropriate
   * binding local to this injector and remembers it.
   *
   * TODO: think about this wrt parent jit bindings
   */
  @SuppressWarnings("unchecked")
  private <T> BindingImpl<T> getParentBinding(Key<T> key) {
    synchronized (parentBindings) {
      // null values will mean that the parent doesn't have this binding
      BindingImpl<T> binding = (BindingImpl<T>) parentBindings.get(key);
      if (binding != null) {
        return (BindingImpl<T>) binding;
      }
      try {
        binding = (BindingImpl) parentInjector.getBinding(key);
      }
      catch (ProvisionException e) {
        // if this happens, the parent can't create this key, and we ignore it
      }

      BindingImpl<T> bindingImpl = null;
      if (binding != null
          && binding.getScope() != null
          && !binding.getScope().equals(Scopes.NO_SCOPE)) {
        // TODO: this binding won't report its injection points or scoping properly
        bindingImpl = new ProviderInstanceBindingImpl(
            this,
            key,
            binding.getSource(),
            new InternalFactoryToProviderAdapter(binding.getProvider(), binding.getSource()),
            Scopes.NO_SCOPE,
            binding.getProvider(),
            LoadStrategy.LAZY,
            ImmutableSet.<InjectionPoint>of());
      }
      parentBindings.put(key, bindingImpl); // this kinda scares me
      return bindingImpl;
    }
  }

