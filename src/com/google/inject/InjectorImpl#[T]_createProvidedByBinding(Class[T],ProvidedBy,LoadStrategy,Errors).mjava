  /** Creates a binding for a type annotated with @ProvidedBy. */
  <T> BindingImpl<T> createProvidedByBinding(final Class<T> type, ProvidedBy providedBy,
      LoadStrategy loadStrategy, Errors errors) throws ErrorsException {
    final Class<? extends Provider<?>> providerType = providedBy.value();

    // Make sure it's not the same type. TODO: Can we check for deeper loops?
    if (providerType == type) {
      throw errors.recursiveProviderType().toException();
    }

    // TODO: Make sure the provided type extends type. We at least check the type at runtime below.

    // Assume the provider provides an appropriate type. We double check at runtime.
    @SuppressWarnings("unchecked")
    Key<? extends Provider<T>> providerKey = (Key<? extends Provider<T>>) Key.get(providerType);
    final BindingImpl<? extends Provider<?>> providerBinding
        = getBindingOrThrow(providerKey, errors);

    InternalFactory<T> internalFactory = new InternalFactory<T>() {
      public T get(Errors errors, InternalContext context, InjectionPoint injectionPoint)
          throws ErrorsException {
        Provider<?> provider = providerBinding.internalFactory.get(errors, context, injectionPoint);
        Object o = provider.get();
        if (o != null && !type.isInstance(o)) {
          throw errors.withSource(StackTraceElements.forType(type))
              .subtypeNotProvided(providerType, type).toException();
        }

        @SuppressWarnings("unchecked") // protected by isInstance() check above
        T t = (T) o;
        return t;
      }
    };

    return new LinkedProviderBindingImpl<T>(
        this,
        Key.get(type),
        StackTraceElements.forType(type),
        internalFactory,
        Scopes.NO_SCOPE,
        providerKey,
        loadStrategy);
  }

