  /**
   * Performs creation-time injections on all objects that require it. Whenever fulfilling an
   * injection depends on another object that requires injection, we use {@link
   * #ensureInjected(Object,com.google.inject.internal.Errors)} to inject that member first.
   *
   * <p>If the two objects are codependent (directly or transitively), ordering of injection is
   * arbitrary.
   */
  void injectAll(final Errors errors) {
    // loop over a defensive copy since ensureInjected() mutates the set. Unfortunately, that copy
    // is made complicated by a bug in IBM's JDK, wherein entrySet().toArray(Object[]) doesn't work
    for (Object entryObject : outstandingInjections.entrySet().toArray()) {
      @SuppressWarnings("unchecked")
      Entry<Object, Object> entry = (Entry<Object, Object>) entryObject;
      try {
        Object toInject = entry.getKey();
        Object source = entry.getValue();
        ensureInjected(toInject, errors.withSource(source));
      } catch (ErrorsException e) {
        errors.merge(e.getErrors());
      }
    }

    if (!outstandingInjections.isEmpty()) {
      throw new AssertionError("Failed to satisfy " + outstandingInjections);
    }

    ready.countDown();
  }

