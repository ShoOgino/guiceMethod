    private <T> Constructor<T> findConstructorIn(Errors errors, Class<T> implementation)
        throws ErrorsException {
      Constructor<T> found = null;
      @SuppressWarnings("unchecked")
      Constructor<T>[] constructors
          = (Constructor<T>[]) implementation.getDeclaredConstructors();
      for (Constructor<T> constructor : constructors) {
        Inject inject = constructor.getAnnotation(Inject.class);
        if (inject != null) {
          if (inject.optional()) {
            errors.optionalConstructor(constructor);
          }

          if (found != null) {
            errors.tooManyConstructors(implementation);
          }

          found = constructor;
        }
      }
      if (found != null) {
        return found;
      }

      // If no annotated constructor is found, look for a no-arg constructor
      // instead.
      try {
        Constructor<T> noArgCtor = implementation.getDeclaredConstructor();

        // Disallow private constructors on non-private classes (unless they have @Inject)
        if (Modifier.isPrivate(noArgCtor.getModifiers())
            && !Modifier.isPrivate(implementation.getModifiers())) {
          errors.missingConstructor(implementation);
        }
        return noArgCtor;
      }
      catch (NoSuchMethodException e) {
        throw errors.missingConstructor(implementation).toException();
      }
    }

