    <T> void bindProviderMethod(final Method method) {
      Errors errors = new Errors(method);

      method.setAccessible(true);

      Class<? extends Annotation> scopeAnnotation
          = Scopes.findScopeAnnotation(errors, method.getAnnotations());
      Annotation bindingAnnotation
          = Keys.findBindingAnnotation(errors, method, method.getAnnotations());

      final List<Provider<?>> parameterProviders = findParameterProviders(errors, method);

      for (Message message : errors.getMessages()) {
        binder.addError(message);
      }

      // Define T as the method's return type.
      @SuppressWarnings("unchecked")
      TypeLiteral<T> returnType
          = (TypeLiteral<T>) TypeLiteral.get(typeResolver.getReturnType(method));

      Provider<T> provider = new Provider<T>() {
        public T get() {
          Object[] parameters = new Object[parameterProviders.size()];
          for (int i = 0; i < parameters.length; i++) {
            parameters[i] = parameterProviders.get(i).get();
          }

          try {
            // We know this cast is safe becase T is the method's return type.
            @SuppressWarnings({ "unchecked", "UnnecessaryLocalVariable" })
            T result = (T) method.invoke(providers, parameters);
            return result;
          }
          catch (IllegalAccessException e) {
            throw new AssertionError(e);
          }
          catch (InvocationTargetException e) {
            throw new RuntimeException(e);
          }
        }
      };

      AnnotatedBindingBuilder<T> builder = binder.bind(returnType);

      if (bindingAnnotation != null) {
        builder.annotatedWith(bindingAnnotation);
      }

      builder.toProvider(provider);

      if (scopeAnnotation != null) {
        builder.in(scopeAnnotation);
      }
    }

