    <T> void bindProviderMethod(final Method method) {
      Errors errors = new Errors()
          .pushSource(StackTraceElements.forMember(method));

      method.setAccessible(true);

      Class<? extends Annotation> scopeAnnotation
          = findScopeAnnotation(errors, method.getAnnotations());
      Annotation bindingAnnotation
          = Keys.findBindingAnnotation(errors, method, method.getAnnotations());

      final List<Provider<?>> parameterProviders = findParameterProviders(errors, method);

      for (Message message : errors.getMessages()) {
        addError(message);
      }

      // Define T as the method's return type.
      @SuppressWarnings("unchecked")
      TypeLiteral<T> returnType = (TypeLiteral<T>) TypeLiteral.get(method.getGenericReturnType());

      Provider<T> provider = new Provider<T>() {
        public T get() {
          Object[] parameters = new Object[parameterProviders.size()];
          for (int i = 0; i < parameters.length; i++) {
            parameters[i] = parameterProviders.get(i).get();
          }

          try {
            // We know this cast is safe becase T is the method's return type.
            @SuppressWarnings({ "unchecked", "UnnecessaryLocalVariable" }) T result = (T) method
                .invoke(providers, parameters);
            return result;
          }
          catch (IllegalAccessException e) {
            throw new AssertionError(e);
          }
          catch (InvocationTargetException e) {
            throw new RuntimeException(e);
          }
        }
      };

      if (scopeAnnotation == null && bindingAnnotation == null) {
        bind(returnType).toProvider(provider);
      } else if (scopeAnnotation == null) {
        bind(returnType).annotatedWith(bindingAnnotation).toProvider(provider);
      } else if (bindingAnnotation == null) {
        bind(returnType).toProvider(provider).in(scopeAnnotation);
      } else {
        bind(returnType)
            .annotatedWith(bindingAnnotation)
            .toProvider(provider)
            .in(scopeAnnotation);
      }
    }

