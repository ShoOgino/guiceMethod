  BindingImpl<T> build(InjectorImpl injector) {
    if (this.factory != null) {
      Scope scope = this.scope == null ? Scopes.NO_SCOPE : this.scope;

      InternalFactory<? extends T> scopedFactory
          = Scopes.scope(this.key, injector, this.factory, scope);

      // Instance binding.
      if (instance != null) {
        return new InstanceBindingImpl<T>(
            injector, key, source, scopedFactory, instance);
      }

      // Linked binding.
      if (this.targetKey != null) {
        return new LinkedBindingImpl<T>(
            injector, key, source, scopedFactory, scope, targetKey);
      }

      // Provider instance binding.
      if (this.providerInstance != null) {
        return new ProviderInstanceBindingImpl<T>(
            injector, key, source, scopedFactory, scope, providerInstance);
      }

      // Provider binding.
      if (this.providerKey != null) {
        return new LinkedProviderBindingImpl<T>(
            injector, key, source, scopedFactory, scope, providerKey);
      }

      throw new AssertionError();
    } else {
      // If we're here, the type we bound to is also the implementation.
      // Example: bind(FooImpl.class).in(Scopes.SINGLETON);

      Type type = key.getTypeLiteral().getType();

      // Error: Missing implementation.
      // Example: bind(Date.class).annotatedWith(Red.class);
      // We can't assume abstract types aren't injectable. They may have an
      // @ImplementedBy annotation or something.
      if (key.hasAnnotationType() || !(type instanceof Class<?>)) {
        injector.errorHandler.handle(source,
            ErrorMessages.MISSING_IMPLEMENTATION);
        return invalidBinding(injector);
      }

      // This cast is safe after the preceeding check.
      @SuppressWarnings("unchecked")
      Class<T> clazz = (Class<T>) type;

      BindingImpl<T> binding = injector.createBindingFromType(
          clazz, scope, source);
      // TODO: Should we clean up the binding left behind in jitBindings? 

      if (binding == null) {
        injector.errorHandler.handle(source,
            ErrorMessages.CANNOT_INJECT_ABSTRACT_TYPE, clazz);
        return invalidBinding(injector);
      }

      return binding;
    }
  }

