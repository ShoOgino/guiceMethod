    public Module with(final Iterable<? extends Module> overrides) {
      return new AbstractModule() {
        @Override
        public void configure() {
          final List<Element> elements = Elements.getElements(baseModules);
          final List<Element> overrideElements = Elements.getElements(overrides);

          final Set<Key> overriddenKeys = Sets.newHashSet();
          final Set<Class<? extends Annotation>> overridesScopeAnnotations = Sets.newHashSet();

          // execute the overrides module, keeping track of which keys and scopes are bound
          new ModuleWriter(binder()) {
            @Override public <T> Void visit(Binding<T> binding) {
              overriddenKeys.add(binding.getKey());
              return super.visit(binding);
            }

            @Override public Void visit(ScopeBinding scopeBinding) {
              overridesScopeAnnotations.add(scopeBinding.getAnnotationType());
              return super.visit(scopeBinding);
            }

            @Override public Void visit(PrivateElements privateElements) {
              overriddenKeys.addAll(privateElements.getExposedKeys());
              return super.visit(privateElements);
            }
          }.writeAll(overrideElements);

          // execute the original module, skipping all scopes and overridden keys. We only skip each
          // overridden binding once so things still blow up if the module binds the same thing
          // multiple times.
          final Map<Scope, Object> scopeInstancesInUse = Maps.newHashMap();
          final List<ScopeBinding> scopeBindings = Lists.newArrayList();
          new ModuleWriter(binder()) {
            @Override public <T> Void visit(Binding<T> binding) {
              if (!overriddenKeys.remove(binding.getKey())) {
                super.visit(binding);

                // Record when a scope instance is used in a binding
                Scope scope = getScopeInstanceOrNull(binding);
                if (scope != null) {
                  scopeInstancesInUse.put(scope, binding.getSource());
                }
              }

              return null;
            }

            @Override public Void visit(PrivateElements privateElements) {
              PrivateBinder privateBinder = binder.withSource(privateElements.getSource())
                  .newPrivateBinder();

              Set<Key<?>> skippedExposes = Sets.newHashSet();

              for (Key<?> key : privateElements.getExposedKeys()) {
                if (overriddenKeys.remove(key)) {
                  skippedExposes.add(key);
                } else {
                  privateBinder.withSource(privateElements.getExposedSource(key)).expose(key);
                }
              }

              // we're not skipping deep exposes, but that should be okay. If we ever need to, we
              // have to search through this set of elements for PrivateElements, recursively
              for (Element element : privateElements.getElements()) {
                if (element instanceof Binding
                    && skippedExposes.contains(((Binding) element).getKey())) {
                  continue;
                }
                element.applyTo(privateBinder);
              }

              return null;
            }

            @Override public Void visit(ScopeBinding scopeBinding) {
              scopeBindings.add(scopeBinding);
              return null;
            }
          }.writeAll(elements);

          // execute the scope bindings, skipping scopes that have been overridden. Any scope that
          // is overridden and in active use will prompt an error
          new ModuleWriter(binder()) {
            @Override public Void visit(ScopeBinding scopeBinding) {
              if (!overridesScopeAnnotations.remove(scopeBinding.getAnnotationType())) {
                super.visit(scopeBinding);
              } else {
                Object source = scopeInstancesInUse.get(scopeBinding.getScope());
                if (source != null) {
                  binder().withSource(source).addError(
                      "The scope for @%s is bound directly and cannot be overridden.",
                      scopeBinding.getAnnotationType().getSimpleName());
                }
              }
              return null;
            }
          }.writeAll(scopeBindings);

          // TODO: bind the overridden keys using multibinder
        }

        private Scope getScopeInstanceOrNull(Binding<?> binding) {
          return binding.acceptScopingVisitor(new DefaultBindingScopingVisitor<Scope>() {
            public Scope visitScope(Scope scope) {
              return scope;
            }
          });
        }
      };
    }

