  V internalCreate(K key) {
    FutureValue<V> futureValue = new FutureValue<V>();

    // use a reference so we get the correct equality semantics.
    Object keyReference = referenceKey(key);
    FutureValue<V> previous =
        futures.putIfAbsent(keyReference, futureValue);
    if (previous == null) {
      // winning thread.
      try {
        // check one more time (a previous future could have come and gone.)
        V value = internalGet(key);
        if (value != null) {
          futureValue.setValue(value);
          return value;
        }

        try {
          value = create(futureValue, key);
          if (value == null) {
            throw new NullPointerException(
                "create() returned null for: " + key);
          }
          futureValue.setValue(value);
        } catch (Throwable t) {
          futureValue.setThrowable(t);
          rethrow(t);
        }

        putStrategy().execute(
            this, keyReference, referenceValue(keyReference, value));

        return value;
      } finally {
        futures.remove(keyReference);
      }
    } else {
      // wait for winning thread.
      return previous.get();
    }
  }

