  /**
   * Checks this checker's injector for scoping violations.
   *
   * @param longest the outermost scope, such as {@code Singleton.class}.
   * @param nested a scope immediately nested within {@code longest}
   * @param furtherNested any scopes nested within {@code nested}, in decreasing duration.
   * @throws ConfigurationException if any violations are found.
   */
  public void check(Class<? extends Annotation> longest, Class<? extends Annotation> nested,
      Class<? extends Annotation>... furtherNested) {
    Ranker ranker = new Ranker(longest, nested, furtherNested);
    Map<Key<?>, Node> nodes = Maps.newHashMap();

    // build the graph of node dependencies with scope ranks
    for (Binding<?> binding : injector.getAllBindings().values()) {
      Key<?> key = binding.getKey();
      Node node = getNode(nodes, key);
      ranker.rank(binding, node);

      // explicitly ignore dependencies that come via providers.
      if (binding instanceof ProviderBinding) {
        continue;
      }

      if (binding instanceof HasDependencies) {
        HasDependencies hasDependencies = (HasDependencies) binding;
        for (Dependency<?> dependency : hasDependencies.getDependencies()) {
          getNode(nodes, dependency.getKey()).addUser(node);
        }
      }
    }

    // walk through the nodes, pushing effective scopes through dependencies
    for (Node node : nodes.values()) {
      node.pushScopeToUsers();
    }

    // on the nodes with dependencies narrower than themselves, print an error
    List<Message> messages = Lists.newArrayList();
    for (Node node : nodes.values()) {
      if (node.isScopedCorrectly()) {
        continue;
      }

      StringBuilder error = new StringBuilder("Illegal scoped dependency: ").append(node);
      Node dependency = node;
      do {
        dependency = dependency.effectiveScopeDependency();
        error.append("\n  depends on ").append(dependency);
      } while (!dependency.isEffectiveScopeAppliedScope());
      messages.add(new Message(error.toString()));
    }

    if (!messages.isEmpty()) {
      throw new ConfigurationException(messages);
    }
  }

